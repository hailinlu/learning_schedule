## V8垃圾回收机制

    Node在Javascript的执行上直接受益于V8，可以随着V8的升级享受更好的性能或新的语言特性，但同时也会受到V8的一些限制。

### V8内存限制
    
        Node无法进行大内存对象操作，尽管大部分情况下这种情况并不多见，但是根据《深入浅出Node.js》中所述，Node通过JS使用内存时仅能使用部分内存。
    这个问题其实也是因为Node是基于V8引擎构建的。

### V8对象分配
    
        V8中，JS对象的内存是通过堆来进行分配的。可以通过process.memoryUsage()查看内存。之所以V8会对内存进行限制，
    超过限制的话，V8进行堆内存的垃圾回收会使应用的性能和响应能力直线下降。当然限制也是可以打开的，具体方式如下：

```
    node --max-old-space-size=1700 test.js
```

### 垃圾回收机制
        
    V8的内存分代：分为新生代和老生代两代。新生代的对象为存活时间较短的对象，老生代的对象为存活时间较长或常驻内存对象
    
#### Scavenge算法
    
        V8的新生代对象主要通过Scavenge算法的Cheney算法进行垃圾回收。Cheney算法是通过复制的方式实现的垃圾回收。
    简单来说，就是将内存空间一分为二，一个处于使用状态（From空间），一个处于闲置状态（To空间）。分配对象时在From空间中进行，
    当垃圾回收的时候，检查From空间的存活对象复制到To空间，非存活的对象将会释放，复制完成后，From和To空间互换。
    在整个过程，会检查对象是否被垃圾回收过，或者，To空间的使用率是否超过25%，满足条件，则对象的晋升到老生代，
    垃圾回收算法使用老生代的算法。缺点：只能使用堆内存的一半。

#### Mark-Sweep & Mark-Compact
    
        Mark-Sweep是标记清除的意思，按字面意思来讲，分为标记和清除两个阶段，也就是标记存活对象，清除未标记对象
    但是这种方式会造成内存空间的不连续，所以Mark-Compact（标记整理）被提出来，在对象标记为死亡后，将存活对象往一端移动，
    然后直接清理掉边界外的内存。